# Incubation Update - December 2020

## Overview

URLPattern is a new web API for matching URLs.  Its intended to both provide a convenient API for web developers and to be usable in other web APIs that need to match URLs; e.g. service workers.  The [explainer](explainer.md) discusses the motivating use cases.  There is also a [design document](https://docs.google.com/document/d/17L6b3zlTHtyxQvOAvbK55gQOi5rrJLERwjt_sKXpzqc/edit?usp=sharing) that goes into more details.

Currently URLPattern is in [development](https://www.chromestatus.com/feature/5731920199548928) in chromium.  A specification has not been written yet.  Once the initial prototype is complete we will gather feedback and iterate.  When the API seems stable we will then codify it in a spec.

URLPattern's integration with service workers is not being worked on yet.  We want to get URLPattern in a solid shippable state first.

As discussed in the [explainer](explainer.md) and [design document](https://docs.google.com/document/d/17L6b3zlTHtyxQvOAvbK55gQOi5rrJLERwjt_sKXpzqc/edit?usp=sharing), URLPattern is heavily based on Blake Embrey's [path-to-regexp](https://github.com/pillarjs/path-to-regexp) library.  Various versions of this library are used in such projects as [express.js](https://expressjs.com/), [koa.js](https://koajs.com/), and [react-router](https://reactrouter.com/).  By using a popular matching library with existing traction we hope to follow a well lit path and deliver a useful API to web developers.

To that end we have implemented a large portion of path-to-regexp in C++ in an MIT licensed library called liburlpattern.  It is currently being developed in the chromium source tree [here](https://source.chromium.org/chromium/chromium/src/+/master:third_party/liburlpattern/).  This implementation is based on version 6.2.0 of path-to-regexp.  In addition, we plan to add back support for the `*` wildcard character that was previously in path-to-regexp up to version 1.7.0.

Currently there is a partial implementation of URLPattern available in chrome canary.  To access it you must enable experimental web features by enabling a [flag](chrome://flags/#enable-experimental-web-platform-features).  The following discusses the implementation as of version 89.0.TBD.TBD.

## API

The API currently consists of the `URLPattern()` constructor and two matching methods; `test()` and `exec()`.  The related webidl can be found [here](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/modules/url_pattern/).

### Constructor

The `URLPattern()` constructor accepts a single object argument.  This dictionary can contain separate patterns for each URL component.  For example (see [path-to-regexp](https://github.com/pillarjs/path-to-regexp) for pattern syntax):

```javascript
const p = new URLPattern({
  protocol: 'https',
  username: '',
  password: '',
  hostname: 'example.com',
  port: '',
  pathname: '/foo/:image.jpg',
  search: '(.*)',
  hash: '(.*)',
});
```

This is example is very verbose.  Fortunately it can be simplified.  First, if a component is not specified it defaults to the `(.*)` wildcard pattern.  So we can write:

```javascript
const p = new URLPattern({
  protocol: 'https',
  username: '',
  password: '',
  hostname: 'example.com',
  port: '',
  pathname: '/foo/:image.jpg',
});
```

This is still pretty long, though.  To further simplify we can provide the fixed origin patterns via a `baseURL` property.

```javascript
const p = new URLPattern({
  pathname: '/foo/:image.jpg',
  baseURL: 'https://example.com',
});
```

So far all of the above code snippets have been equivalent.  If it turns out we only really care about finding image file names and don't need strict origin checking we can even just leave the baseURL off completely.  This will be a more lenient, different pattern, but its quite brief:

```javascript
const p = new URLPattern({ pathname: '/foo/:image.jpg' });
```

The constructor also supports relative pathnames.  For example, the following is equivalent to the first snippet above.

```javascript
const p = new URLPattern({
  pathname: ':image.jpg',
  baseURL: 'https://example.com/foo/',
});
```

Currently URLPattern does not perform any encoding or normalization of the patterns.  So a developer would need to URL encode unicode characters before passing the pattern into the constructor.  Similarly, the constructor does not do things like flattening pathnames such as `/foo/../bar` to `/bar`.  Currently the pattern must be written to target canonical URL output manually.  There is an [open question](#open-questions) below whether the constructor should try to help more here or not.

### Matching

Both the `test()` and `exec()` methods take the same input and perform the same matching algorithm.  They only differ in their return value.  So let's discuss the common parts first.

The matching methods take a single argument consisting of either a string or a dictionary object like the one used in the constructor.

In the case of the string it is parsed as a URL.  Each component of the URL is then compared to the URLPattern's component pattern one by one.  If they all match, then the entire matching operation succeeds.  Otherwise the match fails.

In the case of the dictionary object the provided then the initial URL parsing step is skipped.  Instead the components are individually encoded and normalized per normal URL rules.  In addition, baseURL resolution is supported.  Any missing components are assumed to be the empty string.  The components are then again compared against the URLPattern's component patterns one by one.  Again, if they all match then the overall operation succeeds.

To make that a bit more concrete, these two method calls are equivalent:

```javascript
// string input
p.test('https://example.com/foo/bar');

// dictionary intput
p.test({
  pathname: '/foo/bar',
  baseURL: 'https://example.com',
});
```

The dictionary input, though, is really intended as a convenience for when you only have part of a URL available.  For example, maybe you only have a pathname and not a full URL available.  For example:

```javascript
// we only care about the pathname
const p = new URLPattern({ pathname: '/foo/:name' });

// we only provide the pathname
p.test({ pathname: '/foo/bar' });
```

## What's Still Left To Do

## Open Questions

## Ackowledgements
